//=============================================================================
// Multi-Timeframe Trend Analyzer [Lab]
//=============================================================================
//
// WHAT THIS DEMONSTRATES
//  - Requesting data from multiple timeframes
//  - Aligning different timeframe signals
//  - Creating a comprehensive trend dashboard
//  - MTF (Multi-TimeFrame) analysis best practices
//
// EDUCATIONAL FOCUS
//  - request.security() function usage
//  - Timeframe string handling
//  - Aggregating multiple signals
//  - Dashboard visualization techniques
//
// PRACTICAL APPLICATION
//  - Get bird's eye view of trend across timeframes
//  - Identify alignment for high-probability setups
//  - Avoid counter-trend trading
//  - Spot divergences between timeframes
//
//=============================================================================
//@version=5
indicator("Multi-Timeframe Trend Analyzer [Lab]", overlay = true, max_labels_count = 1, max_tables_count = 1)

//-----------------------------------------------------------------------------
// INPUTS
//-----------------------------------------------------------------------------
groupTimeframes = "Timeframes"
tf1 = input.timeframe("5", "Timeframe 1", group = groupTimeframes)
tf2 = input.timeframe("15", "Timeframe 2", group = groupTimeframes)
tf3 = input.timeframe("60", "Timeframe 3", group = groupTimeframes)
tf4 = input.timeframe("240", "Timeframe 4", group = groupTimeframes)
tf5 = input.timeframe("D", "Timeframe 5", group = groupTimeframes)

groupMethod = "Trend Detection Method"
trendMethod = input.string("MA Cross", "Method", 
     options = ["MA Cross", "Supertrend", "EMA Slope", "Price Action"], 
     group = groupMethod,
     tooltip = "Choose how trend is determined on each timeframe")

groupMA = "Moving Average Settings"
fastLength = input.int(10, "Fast MA Length", minval = 1, group = groupMA)
slowLength = input.int(20, "Slow MA Length", minval = 1, group = groupMA)
maType = input.string("EMA", "MA Type", options = ["SMA", "EMA"], group = groupMA)

groupSupertrend = "Supertrend Settings"
stPeriod = input.int(10, "Supertrend Period", minval = 1, group = groupSupertrend)
stMultiplier = input.float(3.0, "Supertrend Multiplier", minval = 0.1, step = 0.1, group = groupSupertrend)

groupVisual = "Display Settings"
tablePosition = input.string("Top Right", "Table Position", 
     options = ["Top Left", "Top Center", "Top Right", "Middle Left", "Middle Center", 
                "Middle Right", "Bottom Left", "Bottom Center", "Bottom Right"],
     group = groupVisual)
showCurrentTF = input.bool(false, "Show Current Timeframe", group = groupVisual,
     tooltip = "Include the chart's current timeframe in the analysis")

//-----------------------------------------------------------------------------
// MOVING AVERAGE CALCULATION
//-----------------------------------------------------------------------------
f_ma(src, length, maType) =>
    maType == "SMA" ? ta.sma(src, length) : ta.ema(src, length)

//-----------------------------------------------------------------------------
// SUPERTREND CALCULATION
//-----------------------------------------------------------------------------
// Returns [trend, direction]: trend is Supertrend value, direction is 1 for up, -1 for down
f_supertrend(factor, atrPeriod) =>
    src = hl2
    atr = ta.atr(atrPeriod)
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    
    var float supertrend = na
    var int direction = 1
    
    prevSupertrend = supertrend
    
    if na(atr[1])
        direction := 1
        supertrend := lowerBand
    else
        if prevSupertrend == nz(prevSupertrend[1])
            lowerBand := close[1] > prevSupertrend ? math.max(lowerBand, nz(lowerBand[1])) : lowerBand
            upperBand := close[1] < prevSupertrend ? math.min(upperBand, nz(upperBand[1])) : upperBand
        
        if close > prevSupertrend
            direction := 1
            supertrend := lowerBand
        else if close < prevSupertrend
            direction := -1
            supertrend := upperBand
        else
            direction := direction[1]
            supertrend := direction == 1 ? lowerBand : upperBand
    
    [supertrend, direction]

//-----------------------------------------------------------------------------
// TREND DETERMINATION FUNCTIONS
//-----------------------------------------------------------------------------

// Method 1: MA Crossover
f_trendByMA() =>
    fastMA = f_ma(close, fastLength, maType)
    slowMA = f_ma(close, slowLength, maType)
    fastMA > slowMA ? 1 : fastMA < slowMA ? -1 : 0

// Method 2: Supertrend
f_trendBySupertrend() =>
    [st, dir] = f_supertrend(stMultiplier, stPeriod)
    dir

// Method 3: EMA Slope
f_trendBySlope() =>
    ema = ta.ema(close, slowLength)
    slope = ema - ema[1]
    
    // Check if slope is consistent over multiple bars
    upCount = 0
    downCount = 0
    for i = 0 to 4
        s = ema[i] - ema[i + 1]
        if s > 0
            upCount += 1
        else if s < 0
            downCount += 1
    
    upCount >= 3 ? 1 : downCount >= 3 ? -1 : 0

// Method 4: Price Action (Higher Highs / Lower Lows)
f_trendByPriceAction() =>
    // Look at last 20 bars
    lookback = 20
    recentHigh = ta.highest(high, lookback)
    recentLow = ta.lowest(low, lookback)
    prevHigh = ta.highest(high[lookback], lookback)
    prevLow = ta.lowest(low[lookback], lookback)
    
    higherHigh = recentHigh > prevHigh
    higherLow = recentLow > prevLow
    lowerHigh = recentHigh < prevHigh
    lowerLow = recentLow < prevLow
    
    (higherHigh and higherLow) ? 1 : (lowerHigh and lowerLow) ? -1 : 0

// Main trend function - routes to selected method
f_getTrend() =>
    trendMethod == "MA Cross" ? f_trendByMA() :
     trendMethod == "Supertrend" ? f_trendBySupertrend() :
     trendMethod == "EMA Slope" ? f_trendBySlope() :
     f_trendByPriceAction()

//-----------------------------------------------------------------------------
// REQUEST DATA FROM MULTIPLE TIMEFRAMES
//-----------------------------------------------------------------------------
//
// IMPORTANT: request.security() best practices
//  1. Avoid repainting: use lookahead = barmerge.lookahead_off
//  2. Be careful with gaps = barmerge.gaps_on (can create na values)
//  3. Lower TF data on higher TF chart = repaints
//  4. Higher TF data on lower TF chart = safe (our use case)
//

// Get trend from current timeframe
currentTrend = f_getTrend()

// Request trends from specified timeframes
tf1Trend = request.security(syminfo.tickerid, tf1, f_getTrend(), 
     lookahead = barmerge.lookahead_off)
tf2Trend = request.security(syminfo.tickerid, tf2, f_getTrend(), 
     lookahead = barmerge.lookahead_off)
tf3Trend = request.security(syminfo.tickerid, tf3, f_getTrend(), 
     lookahead = barmerge.lookahead_off)
tf4Trend = request.security(syminfo.tickerid, tf4, f_getTrend(), 
     lookahead = barmerge.lookahead_off)
tf5Trend = request.security(syminfo.tickerid, tf5, f_getTrend(), 
     lookahead = barmerge.lookahead_off)

//-----------------------------------------------------------------------------
// TREND ALIGNMENT ANALYSIS
//-----------------------------------------------------------------------------

// Count aligned timeframes
upCount = 0
downCount = 0
neutralCount = 0

// Array of all trends for easy iteration
var trendArray = array.new<int>(6)
array.set(trendArray, 0, showCurrentTF ? currentTrend : na(int))
array.set(trendArray, 1, tf1Trend)
array.set(trendArray, 2, tf2Trend)
array.set(trendArray, 3, tf3Trend)
array.set(trendArray, 4, tf4Trend)
array.set(trendArray, 5, tf5Trend)

for i = 0 to array.size(trendArray) - 1
    trend = array.get(trendArray, i)
    if not na(trend)
        if trend > 0
            upCount += 1
        else if trend < 0
            downCount += 1
        else
            neutralCount += 1

// Calculate total active timeframes
totalTFs = upCount + downCount + neutralCount

// Determine overall alignment
overallTrend = upCount > downCount ? 1 : downCount > upCount ? -1 : 0
alignmentStrength = totalTFs > 0 ? (math.max(upCount, downCount) / totalTFs) * 100 : 0

//-----------------------------------------------------------------------------
// HELPER FUNCTIONS FOR DISPLAY
//-----------------------------------------------------------------------------

// Convert trend integer to text
f_trendToText(trend) =>
    trend > 0 ? "↑ UP" : trend < 0 ? "↓ DOWN" : "→ NEUTRAL"

// Convert trend to color
f_trendToColor(trend) =>
    trend > 0 ? color.new(color.lime, 0) : 
     trend < 0 ? color.new(color.red, 0) : 
     color.new(color.gray, 0)

// Get table position
f_getTablePosition(pos) =>
    pos == "Top Left" ? position.top_left :
     pos == "Top Center" ? position.top_center :
     pos == "Top Right" ? position.top_right :
     pos == "Middle Left" ? position.middle_left :
     pos == "Middle Center" ? position.middle_center :
     pos == "Middle Right" ? position.middle_right :
     pos == "Bottom Left" ? position.bottom_left :
     pos == "Bottom Center" ? position.bottom_center :
     position.bottom_right

//-----------------------------------------------------------------------------
// CREATE DASHBOARD TABLE
//-----------------------------------------------------------------------------
var table dashboard = table.new(f_getTablePosition(tablePosition), 
     columns = 3, rows = 9, 
     bgcolor = color.new(color.black, 80),
     border_width = 2,
     border_color = color.new(color.gray, 50))

if barstate.islast
    // Header row
    table.cell(dashboard, 0, 0, "MULTI-TIMEFRAME TREND ANALYSIS", 
         text_color = color.white, text_size = size.normal, bgcolor = color.new(color.navy, 70))
    table.merge_cells(dashboard, 0, 0, 2, 0)
    
    // Column headers
    table.cell(dashboard, 0, 1, "Timeframe", text_color = color.silver, text_size = size.small, bgcolor = color.new(color.gray, 80))
    table.cell(dashboard, 1, 1, "Trend", text_color = color.silver, text_size = size.small, bgcolor = color.new(color.gray, 80))
    table.cell(dashboard, 2, 1, "Signal", text_color = color.silver, text_size = size.small, bgcolor = color.new(color.gray, 80))
    
    // Current timeframe (optional)
    row = 2
    if showCurrentTF
        table.cell(dashboard, 0, row, timeframe.period, text_color = color.white, text_size = size.small)
        table.cell(dashboard, 1, row, f_trendToText(currentTrend), 
             text_color = f_trendToColor(currentTrend), text_size = size.small)
        table.cell(dashboard, 2, row, "⬤", 
             text_color = f_trendToColor(currentTrend), text_size = size.large)
        row += 1
    
    // Timeframe 1
    table.cell(dashboard, 0, row, tf1, text_color = color.white, text_size = size.small)
    table.cell(dashboard, 1, row, f_trendToText(tf1Trend), 
         text_color = f_trendToColor(tf1Trend), text_size = size.small)
    table.cell(dashboard, 2, row, "⬤", 
         text_color = f_trendToColor(tf1Trend), text_size = size.large)
    
    // Timeframe 2
    table.cell(dashboard, 0, row + 1, tf2, text_color = color.white, text_size = size.small)
    table.cell(dashboard, 1, row + 1, f_trendToText(tf2Trend), 
         text_color = f_trendToColor(tf2Trend), text_size = size.small)
    table.cell(dashboard, 2, row + 1, "⬤", 
         text_color = f_trendToColor(tf2Trend), text_size = size.large)
    
    // Timeframe 3
    table.cell(dashboard, 0, row + 2, tf3, text_color = color.white, text_size = size.small)
    table.cell(dashboard, 1, row + 2, f_trendToText(tf3Trend), 
         text_color = f_trendToColor(tf3Trend), text_size = size.small)
    table.cell(dashboard, 2, row + 2, "⬤", 
         text_color = f_trendToColor(tf3Trend), text_size = size.large)
    
    // Timeframe 4
    table.cell(dashboard, 0, row + 3, tf4, text_color = color.white, text_size = size.small)
    table.cell(dashboard, 1, row + 3, f_trendToText(tf4Trend), 
         text_color = f_trendToColor(tf4Trend), text_size = size.small)
    table.cell(dashboard, 2, row + 3, "⬤", 
         text_color = f_trendToColor(tf4Trend), text_size = size.large)
    
    // Timeframe 5
    table.cell(dashboard, 0, row + 4, tf5, text_color = color.white, text_size = size.small)
    table.cell(dashboard, 1, row + 4, f_trendToText(tf5Trend), 
         text_color = f_trendToColor(tf5Trend), text_size = size.small)
    table.cell(dashboard, 2, row + 4, "⬤", 
         text_color = f_trendToColor(tf5Trend), text_size = size.large)
    
    // Summary section
    table.cell(dashboard, 0, row + 5, "ALIGNMENT", 
         text_color = color.silver, text_size = size.small, bgcolor = color.new(color.gray, 80))
    table.merge_cells(dashboard, 0, row + 5, 2, row + 5)
    
    // Overall trend
    table.cell(dashboard, 0, row + 6, "Overall Trend:", text_color = color.silver, text_size = size.small)
    table.cell(dashboard, 1, row + 6, f_trendToText(overallTrend), 
         text_color = f_trendToColor(overallTrend), text_size = size.normal)
    table.merge_cells(dashboard, 1, row + 6, 2, row + 6)
    
    // Alignment strength
    alignmentText = str.tostring(alignmentStrength, "#.#") + "%"
    alignmentColor = alignmentStrength >= 80 ? color.lime : 
         alignmentStrength >= 60 ? color.yellow : color.orange
    
    table.cell(dashboard, 0, row + 7, "Strength:", text_color = color.silver, text_size = size.small)
    table.cell(dashboard, 1, row + 7, alignmentText, 
         text_color = alignmentColor, text_size = size.normal)
    table.merge_cells(dashboard, 1, row + 7, 2, row + 7)

//-----------------------------------------------------------------------------
// CHART COLORING BASED ON ALIGNMENT
//-----------------------------------------------------------------------------
// Color the chart background based on overall alignment strength
bgcolor(overallTrend == 1 and alignmentStrength >= 80 ? color.new(color.lime, 95) : 
     overallTrend == -1 and alignmentStrength >= 80 ? color.new(color.red, 95) : na,
     title = "Strong Alignment")

//-----------------------------------------------------------------------------
// ALERTS
//-----------------------------------------------------------------------------
// Alert when all timeframes align
allAlignedUp = upCount == totalTFs and totalTFs > 0
allAlignedDown = downCount == totalTFs and totalTFs > 0

alertcondition(allAlignedUp, "All Timeframes Bullish", "All timeframes aligned BULLISH on {{ticker}}")
alertcondition(allAlignedDown, "All Timeframes Bearish", "All timeframes aligned BEARISH on {{ticker}}")
alertcondition(alignmentStrength >= 80, "Strong Alignment (80%+)", 
     "Strong {{plot_0}} alignment ({{plot_1}}%) on {{ticker}}")

//-----------------------------------------------------------------------------
// TRADING WITH MULTI-TIMEFRAME ANALYSIS
//-----------------------------------------------------------------------------
//
// Key Concepts:
//
// 1. TIMEFRAME HIERARCHY
//    - Higher timeframes = more significant
//    - Lower timeframes = better entry timing
//    - Trade in direction of higher TFs
//    - Use lower TFs for entries
//
// 2. ALIGNMENT STRATEGIES
//    - 100% Alignment = Strongest signal, rarest
//    - 80%+ Alignment = Very strong, tradeable
//    - 60-79% Alignment = Moderate, needs confirmation
//    - <60% Alignment = Avoid or reduce size
//
// 3. TOP-DOWN APPROACH
//    - Start with highest timeframe
//    - Identify overall trend direction
//    - Move to lower timeframes for entries
//    - Example: Daily up → 4H pullback → 1H entry
//
// 4. DIVERGENCE OPPORTUNITIES
//    - When lower TF opposes higher TF = counter-trend bounce
//    - Use for scalping or quick trades only
//    - Risk management critical
//    - Exit quickly when TFs realign
//
// 5. PRACTICAL EXAMPLES
//    - Day Trading: Use 5m, 15m, 1H, 4H, Daily
//    - Swing Trading: Use 1H, 4H, Daily, Weekly, Monthly
//    - Scalping: Use 1m, 5m, 15m, 1H, 4H
//
// 6. ENTRY TIMING
//    - Wait for HTF confirmation
//    - Enter on LTF signal
//    - Place stop based on HTF structure
//    - Take profit at HTF targets
//
//-----------------------------------------------------------------------------
// ADVANCED CONCEPTS
//-----------------------------------------------------------------------------
//
// MTF Confluence:
//  - Use multiple MTF indicators (trend, momentum, volatility)
//  - Check MTF support/resistance
//  - Analyze MTF volume patterns
//  - Combine with MTF order flow
//
// Adaptive Timeframe Selection:
//  - Volatile markets: use higher TFs
//  - Ranging markets: use lower TFs
//  - Trending markets: align multiple TFs
//
// Timeframe Gaps:
//  - Too many TFs = paralysis
//  - Too few TFs = narrow view
//  - Optimal: 3-5 timeframes with clear hierarchy
//
// Repaint Prevention:
//  - Always use barmerge.lookahead_off
//  - Test on historical data
//  - Verify signals don't change after bar close
