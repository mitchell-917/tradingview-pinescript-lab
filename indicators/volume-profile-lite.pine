//=============================================================================
// Volume Profile Lite [Lab]
//=============================================================================
//
// GOAL
//  - Very simple, approximate "volume profile" style display using price bins.
//  - Educational: shows how arrays & loops can be used to build custom tools.
//
// IMPORTANT LIMITATIONS
//  - Pine Script doesn't give true volume-at-price for each tick.
//  - We approximate by taking the closing price of each bar and assigning its
//    volume to a price bin.
//  - For performance, the profile is recomputed only on the last bar.
//
// HOW IT WORKS
//  1. Define a lookback window in bars.
//  2. Split the price range of that window into N bins.
//  3. For each bar in the window, add its volume into the relevant bin.
//  4. Draw horizontal boxes showing relative volume at each price band.
//
// TRY THIS
//  - Different instruments, timeframes, and lookback settings.
//  - Overlay it with your support/resistance tools to see where volume clusters.
//
//=============================================================================
//@version=5
indicator("Volume Profile Lite [Lab]", overlay = true, max_boxes_count = 500)

//-----------------------------------------------------------------------------
// INPUTS
//-----------------------------------------------------------------------------
groupProfile = "Profile Settings"
bins         = input.int(24, "Number of Price Bins", minval = 4, maxval = 140, group = groupProfile)
lookback     = input.int(250, "Lookback Bars",       minval = 50, maxval = 2000, group = groupProfile)

useSession   = input.bool(false, "Use Intraday Session Instead of Fixed Lookback", group = groupProfile,
                 tooltip = "When ON, we use only bars from the current session defined below.")
sessionTimes = input.session("0900-1700", "Session Times (Exchange Time)", group = groupProfile)

groupVisual  = "Visual"
baseColor    = input.color(color.new(color.blue, 40), "Base Color", group = groupVisual)
showOutline  = input.bool(true, "Show Box Outline", group = groupVisual)

//-----------------------------------------------------------------------------
// SESSION LOGIC (OPTIONAL)
//-----------------------------------------------------------------------------
inSession = not na(time(timeframe.period, sessionTimes))

//-----------------------------------------------------------------------------
// ARRAYS FOR VOLUME BINS & BOXES
//-----------------------------------------------------------------------------
var float[] volBins   = array.new_float()
var box[]   boxArray  = array.new_box()

// Helper to clear and delete existing boxes
f_clear_boxes() =>
    for i = 0 to array.size(boxArray) - 1
        b = array.get(boxArray, i)
        box.delete(b)
    array.clear(boxArray)

//-----------------------------------------------------------------------------
// MAIN LOGIC (EXECUTED ON LAST BAR ONLY TO SAVE CPU)
//-----------------------------------------------------------------------------
if barstate.islastconfirmedhistory
    // 1) Determine which bars to include
    int barsToUse = lookback
    if useSession
        // Count bars in the current session
        barsToUse := 0
        for i = 0 to lookback - 1
            if inSession[i]
                barsToUse += 1
            else if barsToUse > 0
                // Once we've left the current session going backwards, break
                break

    barsToUse := math.min(barsToUse, lookback)

    // 2) Compute the price range of interest
    float lowest  = ta.lowest(low,  barsToUse)
    float highest = ta.highest(high, barsToUse)

    float priceRange = math.max(highest - lowest, syminfo.mintick)
    float binSize    = priceRange / bins

    // 3) Prepare volume bins
    array.clear(volBins)
    for _ = 0 to bins - 1
        array.push(volBins, 0.0)

    // 4) Accumulate volumes into bins
    for i = 0 to barsToUse - 1
        if not useSession or inSession[i]
            barPrice = close[i]   // using close as representative price
            barVol   = volume[i]

            // Map price to bin index
            float offset = barPrice - lowest
            idx          = int(math.floor(offset / binSize))
            idx          := math.clamp(idx, 0, bins - 1)

            oldVal = array.get(volBins, idx)
            array.set(volBins, idx, oldVal + barVol)

    // 5) Clear old boxes
    f_clear_boxes()

    // 6) Find max volume to normalise the box opacity/width
    float maxVol = 0.0
    for i = 0 to bins - 1
        v = array.get(volBins, i)
        maxVol := math.max(maxVol, v)

    // 7) Draw boxes for each non-zero bin
    if maxVol > 0
        for i = 0 to bins - 1
            volAtBin = array.get(volBins, i)
            if volAtBin > 0
                frac = volAtBin / maxVol   // 0..1

                priceLow  = lowest + binSize * i
                priceHigh = priceLow + binSize

                x1 = bar_index - barsToUse
                x2 = bar_index

                // Use opacity as a visual encoding of volume intensity
                opacity = 100 - int(frac * 80.0)
                bColor  = color.new(baseColor, opacity)
                border  = showOutline ? color.new(baseColor, opacity) : color.new(baseColor, 100)

                b = box.new(
                     x1, priceHigh,
                     x2, priceLow,
                     bgcolor      = bColor,
                     border_color = border
                )
                array.push(boxArray, b)

//-----------------------------------------------------------------------------
// EDUCATIONAL NOTES
//-----------------------------------------------------------------------------
//
// - This is intentionally simple. Real volume profiles use tick-level data and
//   more advanced volume-at-price calculations.
// - You can experiment by:
//      • Changing the number of bins (resolution).
//      • Switching between fixed lookback and session mode.
//      • Comparing where the heaviest volume sits vs your S/R zones.
// - For more accuracy, lower 'lookback' and keep 'bins' moderate to avoid
//   script performance issues.
